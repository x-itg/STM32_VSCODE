ARM GAS  /tmp/ccKABB6j.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32f1xx_hal_pwr.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.PWR_OverloadWfe,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	PWR_OverloadWfe:
  23              	.LFB65:
  24              		.file 1 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
   1:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
   2:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
   3:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @file    stm32f1xx_hal_pwr.c
   4:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @author  MCD Application Team
   5:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
   7:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   8:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   9:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           + Initialization/de-initialization functions
  10:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           + Peripheral Control functions 
  11:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  12:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  13:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @attention
  14:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  15:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
  16:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * All rights reserved.</center></h2>
  17:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  18:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  19:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * the "License"; You may not use this file except in compliance with the
  20:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * License. You may obtain a copy of the License at:
  21:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *                        opensource.org/licenses/BSD-3-Clause
  22:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  23:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  24:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  25:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  26:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  27:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #include "stm32f1xx_hal.h"
  28:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  29:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @addtogroup STM32F1xx_HAL_Driver
  30:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  31:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  32:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  33:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR PWR
  34:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief    PWR HAL module driver
ARM GAS  /tmp/ccKABB6j.s 			page 2


  35:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  36:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  37:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  38:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  39:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  40:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  41:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  42:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  43:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Constants PWR Private Constants
  44:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  45:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  46:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
  47:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  48:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  49:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */ 
  50:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_IT               0x00010000U
  51:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_EVT              0x00020000U
  52:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_RISING_EDGE           0x00000001U
  53:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_FALLING_EDGE          0x00000002U
  54:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  55:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  56:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  57:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  58:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  59:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_register_alias_address PWR Register alias address
  60:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  61:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */ 
  62:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* ------------- PWR registers bit address in the alias region ---------------*/
  63:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  64:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET            0x00U
  65:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET           0x04U
  66:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)
  67:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)
  68:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  69:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  70:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  71:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    
  72:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CR_register_alias PWR CR Register alias address
  73:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  74:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */  
  75:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* --- CR Register ---*/
  76:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of LPSDSR bit */
  77:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define LPSDSR_BIT_NUMBER        PWR_CR_LPDS_Pos
  78:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_LPSDSR_BB             ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPSDSR_BI
  79:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  80:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of DBP bit */
  81:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define DBP_BIT_NUMBER            PWR_CR_DBP_Pos
  82:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_DBP_BB                ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_N
  83:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  84:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of PVDE bit */
  85:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVDE_BIT_NUMBER           PWR_CR_PVDE_Pos
  86:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_PVDE_BB               ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_
  87:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  88:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  89:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  90:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  91:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
ARM GAS  /tmp/ccKABB6j.s 			page 3


  92:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CSR_register_alias PWR CSR Register alias address
  93:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  94:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  95:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  96:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* --- CSR Register ---*/
  97:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of EWUP1 bit */
  98:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CSR_EWUP_BB(VAL)         ((uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (POSITION
  99:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 100:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 101:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 102:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 103:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 104:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 105:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 106:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 107:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
 108:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
 109:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Functions PWR Private Functions
 110:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  * brief   WFE cortex command overloaded for HAL_PWR_EnterSTOPMode usage only (see Workaround secti
 111:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  * @{
 112:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  */
 113:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void);
 114:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 115:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private functions ---------------------------------------------------------*/
 116:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** __NOINLINE
 117:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void)
 118:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
  25              		.loc 1 118 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 1, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30 0000 80B4     		push	{r7}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 4
  33              		.cfi_offset 7, -4
  34 0002 00AF     		add	r7, sp, #0
  35              	.LCFI1:
  36              		.cfi_def_cfa_register 7
 119:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __asm volatile( "wfe" );
  37              		.loc 1 119 0
  38              		.syntax unified
  39              	@ 119 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
  40 0004 20BF     		wfe
  41              	@ 0 "" 2
 120:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __asm volatile( "nop" );
  42              		.loc 1 120 0
  43              	@ 120 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
  44 0006 00BF     		nop
  45              	@ 0 "" 2
 121:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
  46              		.loc 1 121 0
  47              		.thumb
  48              		.syntax unified
  49 0008 00BF     		nop
  50 000a BD46     		mov	sp, r7
  51              	.LCFI2:
ARM GAS  /tmp/ccKABB6j.s 			page 4


  52              		.cfi_def_cfa_register 13
  53              		@ sp needed
  54 000c 80BC     		pop	{r7}
  55              	.LCFI3:
  56              		.cfi_restore 7
  57              		.cfi_def_cfa_offset 0
  58 000e 7047     		bx	lr
  59              		.cfi_endproc
  60              	.LFE65:
  62              		.section	.text.HAL_PWR_DeInit,"ax",%progbits
  63              		.align	1
  64              		.global	HAL_PWR_DeInit
  65              		.syntax unified
  66              		.thumb
  67              		.thumb_func
  68              		.fpu softvfp
  70              	HAL_PWR_DeInit:
  71              	.LFB66:
 122:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 123:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 124:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 125:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 126:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 127:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 128:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions PWR Exported Functions
 129:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 130:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 131:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 132:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
 133:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *  @brief   Initialization and de-initialization functions
 134:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
 135:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @verbatim
 136:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 137:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****               ##### Initialization and de-initialization functions #####
 138:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 139:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 140:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data
 141:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       registers) is protected against possible unwanted
 142:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       write accesses.
 143:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
 144:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
 145:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****             __HAL_RCC_PWR_CLK_ENABLE() macro.
 146:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
 147:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 148:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @endverbatim
 149:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 150:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 151:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 152:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 153:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.  
 154:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 155:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 156:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
 157:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
  72              		.loc 1 157 0
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccKABB6j.s 			page 5


  75              		@ frame_needed = 1, uses_anonymous_args = 0
  76              		@ link register save eliminated.
  77 0000 80B4     		push	{r7}
  78              	.LCFI4:
  79              		.cfi_def_cfa_offset 4
  80              		.cfi_offset 7, -4
  81 0002 00AF     		add	r7, sp, #0
  82              	.LCFI5:
  83              		.cfi_def_cfa_register 7
 158:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_FORCE_RESET();
  84              		.loc 1 158 0
  85 0004 074A     		ldr	r2, .L3
  86 0006 074B     		ldr	r3, .L3
  87 0008 1B69     		ldr	r3, [r3, #16]
  88 000a 43F08053 		orr	r3, r3, #268435456
  89 000e 1361     		str	r3, [r2, #16]
 159:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_RELEASE_RESET();
  90              		.loc 1 159 0
  91 0010 044A     		ldr	r2, .L3
  92 0012 044B     		ldr	r3, .L3
  93 0014 1B69     		ldr	r3, [r3, #16]
  94 0016 23F08053 		bic	r3, r3, #268435456
  95 001a 1361     		str	r3, [r2, #16]
 160:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
  96              		.loc 1 160 0
  97 001c 00BF     		nop
  98 001e BD46     		mov	sp, r7
  99              	.LCFI6:
 100              		.cfi_def_cfa_register 13
 101              		@ sp needed
 102 0020 80BC     		pop	{r7}
 103              	.LCFI7:
 104              		.cfi_restore 7
 105              		.cfi_def_cfa_offset 0
 106 0022 7047     		bx	lr
 107              	.L4:
 108              		.align	2
 109              	.L3:
 110 0024 00100240 		.word	1073876992
 111              		.cfi_endproc
 112              	.LFE66:
 114              		.section	.text.HAL_PWR_EnableBkUpAccess,"ax",%progbits
 115              		.align	1
 116              		.global	HAL_PWR_EnableBkUpAccess
 117              		.syntax unified
 118              		.thumb
 119              		.thumb_func
 120              		.fpu softvfp
 122              	HAL_PWR_EnableBkUpAccess:
 123              	.LFB67:
 161:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 162:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 163:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Enables access to the backup domain (RTC registers, RTC
 164:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         backup data registers ).
 165:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 166:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 167:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
ARM GAS  /tmp/ccKABB6j.s 			page 6


 168:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 169:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
 170:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 124              		.loc 1 170 0
 125              		.cfi_startproc
 126              		@ args = 0, pretend = 0, frame = 0
 127              		@ frame_needed = 1, uses_anonymous_args = 0
 128              		@ link register save eliminated.
 129 0000 80B4     		push	{r7}
 130              	.LCFI8:
 131              		.cfi_def_cfa_offset 4
 132              		.cfi_offset 7, -4
 133 0002 00AF     		add	r7, sp, #0
 134              	.LCFI9:
 135              		.cfi_def_cfa_register 7
 171:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable access to RTC and backup registers */
 172:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
 136              		.loc 1 172 0
 137 0004 034B     		ldr	r3, .L6
 138 0006 0122     		movs	r2, #1
 139 0008 1A60     		str	r2, [r3]
 173:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 140              		.loc 1 173 0
 141 000a 00BF     		nop
 142 000c BD46     		mov	sp, r7
 143              	.LCFI10:
 144              		.cfi_def_cfa_register 13
 145              		@ sp needed
 146 000e 80BC     		pop	{r7}
 147              	.LCFI11:
 148              		.cfi_restore 7
 149              		.cfi_def_cfa_offset 0
 150 0010 7047     		bx	lr
 151              	.L7:
 152 0012 00BF     		.align	2
 153              	.L6:
 154 0014 20000E42 		.word	1108213792
 155              		.cfi_endproc
 156              	.LFE67:
 158              		.section	.text.HAL_PWR_DisableBkUpAccess,"ax",%progbits
 159              		.align	1
 160              		.global	HAL_PWR_DisableBkUpAccess
 161              		.syntax unified
 162              		.thumb
 163              		.thumb_func
 164              		.fpu softvfp
 166              	HAL_PWR_DisableBkUpAccess:
 167              	.LFB68:
 174:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 175:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 176:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Disables access to the backup domain (RTC registers, RTC
 177:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         backup data registers).
 178:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 179:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 180:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 181:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 182:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
ARM GAS  /tmp/ccKABB6j.s 			page 7


 183:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 168              		.loc 1 183 0
 169              		.cfi_startproc
 170              		@ args = 0, pretend = 0, frame = 0
 171              		@ frame_needed = 1, uses_anonymous_args = 0
 172              		@ link register save eliminated.
 173 0000 80B4     		push	{r7}
 174              	.LCFI12:
 175              		.cfi_def_cfa_offset 4
 176              		.cfi_offset 7, -4
 177 0002 00AF     		add	r7, sp, #0
 178              	.LCFI13:
 179              		.cfi_def_cfa_register 7
 184:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable access to RTC and backup registers */
 185:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
 180              		.loc 1 185 0
 181 0004 034B     		ldr	r3, .L9
 182 0006 0022     		movs	r2, #0
 183 0008 1A60     		str	r2, [r3]
 186:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 184              		.loc 1 186 0
 185 000a 00BF     		nop
 186 000c BD46     		mov	sp, r7
 187              	.LCFI14:
 188              		.cfi_def_cfa_register 13
 189              		@ sp needed
 190 000e 80BC     		pop	{r7}
 191              	.LCFI15:
 192              		.cfi_restore 7
 193              		.cfi_def_cfa_offset 0
 194 0010 7047     		bx	lr
 195              	.L10:
 196 0012 00BF     		.align	2
 197              	.L9:
 198 0014 20000E42 		.word	1108213792
 199              		.cfi_endproc
 200              	.LFE68:
 202              		.section	.text.HAL_PWR_ConfigPVD,"ax",%progbits
 203              		.align	1
 204              		.global	HAL_PWR_ConfigPVD
 205              		.syntax unified
 206              		.thumb
 207              		.thumb_func
 208              		.fpu softvfp
 210              	HAL_PWR_ConfigPVD:
 211              	.LFB69:
 187:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 188:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 189:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 190:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 191:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 192:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
 193:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief    Low Power modes configuration functions
 194:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
 195:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @verbatim
 196:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 197:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
ARM GAS  /tmp/ccKABB6j.s 			page 8


 198:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 199:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      
 200:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** PVD configuration ***
 201:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     =========================
 202:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 203:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a
 204:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 205:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 206:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower
 207:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI
 208:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           line16 and can generate an interrupt if enabled. This is done through
 209:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           __HAL_PVD_EXTI_ENABLE_IT() macro.
 210:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) The PVD is stopped in Standby mode.
 211:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 212:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** WakeUp pin configuration ***
 213:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     ================================
 214:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 215:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) WakeUp pin is used to wake up the system from Standby mode. This pin is
 216:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           forced in input pull-down configuration and is active on rising edges.
 217:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) There is one WakeUp pin:
 218:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           WakeUp Pin 1 on PA.00.
 219:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 220:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 221:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 222:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** Low Power modes configuration ***
 223:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     =====================================
 224:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      [..]
 225:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The device features 3 low-power modes:
 226:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Sleep mode: CPU clock off, all peripherals including Cortex-M3 core peripherals like 
 227:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                       NVIC, SysTick, etc. are kept running
 228:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Stop mode: All clocks are stopped
 229:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Standby mode: 1.8V domain powered off
 230:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 231:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 232:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Sleep mode ***
 233:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    ==================
 234:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 235:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 236:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_S
 237:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****               functions with
 238:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 239:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 240:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      
 241:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 242:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WFI entry mode, Any peripheral interrupt acknowledged by the nested vectored interrupt
 243:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 244:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WFE entry mode, Any wakeup event can wake up the device from Sleep mode.
 245:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (+++) Any peripheral interrupt w/o NVIC configuration & SEVONPEND bit set in the Cortex 
 246:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (+++) Any EXTI Line (Internal or External) configured in Event mode
 247:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 248:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Stop mode ***
 249:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    =================
 250:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 251:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The Stop mode is based on the Cortex-M3 deepsleep mode combined with peripheral
 252:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       clock gating. The voltage regulator can be configured either in normal or low-power mode.
 253:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       In Stop mode, all clocks in the 1.8 V domain are stopped, the PLL, the HSI and the HSE RC 
 254:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       oscillators are disabled. SRAM and register contents are preserved.
ARM GAS  /tmp/ccKABB6j.s 			page 9


 255:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       In Stop mode, all I/O pins keep the same state as in Run mode.
 256:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 257:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 258:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_REGULATOR_VALUE, PWR_SLEEPE
 259:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              function with:
 260:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_MAINREGULATOR_ON: Main regulator ON.
 261:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_LOWPOWERREGULATOR_ON: Low Power regulator ON.
 262:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
 263:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
 264:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 265:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) WFI entry mode, Any EXTI Line (Internal or External) configured in Interrupt mode wi
 266:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) WFE entry mode, Any EXTI Line (Internal or External) configured in Event mode.
 267:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 268:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Standby mode ***
 269:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    ====================
 270:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      [..]
 271:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based on the
 272:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       Cortex-M3 deepsleep mode, with the voltage regulator disabled. The 1.8 V domain is 
 273:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       consequently powered off. The PLL, the HSI oscillator and the HSE oscillator are also 
 274:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       switched off. SRAM and register contents are lost except for registers in the Backup domain 
 275:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       and Standby circuitry
 276:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       
 277:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 278:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
 279:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 280:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WKUP pin rising edge, RTC alarm event rising edge, external Reset in 
 281:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              NRSTpin, IWDG Reset
 282:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 283:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 284:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        =============================================
 285:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        [..]
 286:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         
 287:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (+) The MCU can be woken up from low-power mode by an RTC Alarm event, 
 288:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            without depending on an external interrupt (Auto-wakeup mode).
 289:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    
 290:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
 291:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 292:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
 293:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                 configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() functio
 294:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 295:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** PWR Workarounds linked to Silicon Limitation ***
 296:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        ====================================================
 297:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        [..]
 298:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        Below the list of all silicon limitations known on STM32F1xx prouct.
 299:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 300:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (#)Workarounds Implemented inside PWR HAL Driver
 301:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (##)Debugging Stop mode with WFE entry - overloaded the WFE by an internal function    
 302:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         
 303:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @endverbatim
 304:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 305:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 306:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 307:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 308:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 309:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param  sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
 310:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         information for the PVD.
 311:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
ARM GAS  /tmp/ccKABB6j.s 			page 10


 312:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         more details about the voltage threshold corresponding to each
 313:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         detection level.
 314:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 315:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 316:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
 317:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 212              		.loc 1 317 0
 213              		.cfi_startproc
 214              		@ args = 0, pretend = 0, frame = 8
 215              		@ frame_needed = 1, uses_anonymous_args = 0
 216              		@ link register save eliminated.
 217 0000 80B4     		push	{r7}
 218              	.LCFI16:
 219              		.cfi_def_cfa_offset 4
 220              		.cfi_offset 7, -4
 221 0002 83B0     		sub	sp, sp, #12
 222              	.LCFI17:
 223              		.cfi_def_cfa_offset 16
 224 0004 00AF     		add	r7, sp, #0
 225              	.LCFI18:
 226              		.cfi_def_cfa_register 7
 227 0006 7860     		str	r0, [r7, #4]
 318:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 319:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
 320:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
 321:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 322:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set PLS[7:5] bits according to PVDLevel value */
 323:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
 228              		.loc 1 323 0
 229 0008 2A49     		ldr	r1, .L17
 230 000a 2A4B     		ldr	r3, .L17
 231 000c 1B68     		ldr	r3, [r3]
 232 000e 23F0E002 		bic	r2, r3, #224
 233 0012 7B68     		ldr	r3, [r7, #4]
 234 0014 1B68     		ldr	r3, [r3]
 235 0016 1343     		orrs	r3, r3, r2
 236 0018 0B60     		str	r3, [r1]
 324:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 325:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear any previous config. Keep it clear if no event or IT mode is selected */
 326:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 237              		.loc 1 326 0
 238 001a 274A     		ldr	r2, .L17+4
 239 001c 264B     		ldr	r3, .L17+4
 240 001e 5B68     		ldr	r3, [r3, #4]
 241 0020 23F48033 		bic	r3, r3, #65536
 242 0024 5360     		str	r3, [r2, #4]
 327:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_IT();
 243              		.loc 1 327 0
 244 0026 244A     		ldr	r2, .L17+4
 245 0028 234B     		ldr	r3, .L17+4
 246 002a 1B68     		ldr	r3, [r3]
 247 002c 23F48033 		bic	r3, r3, #65536
 248 0030 1360     		str	r3, [r2]
 328:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
 249              		.loc 1 328 0
 250 0032 214A     		ldr	r2, .L17+4
 251 0034 204B     		ldr	r3, .L17+4
ARM GAS  /tmp/ccKABB6j.s 			page 11


 252 0036 DB68     		ldr	r3, [r3, #12]
 253 0038 23F48033 		bic	r3, r3, #65536
 254 003c D360     		str	r3, [r2, #12]
 329:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 255              		.loc 1 329 0
 256 003e 1E4A     		ldr	r2, .L17+4
 257 0040 1D4B     		ldr	r3, .L17+4
 258 0042 9B68     		ldr	r3, [r3, #8]
 259 0044 23F48033 		bic	r3, r3, #65536
 260 0048 9360     		str	r3, [r2, #8]
 330:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 331:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure interrupt mode */
 332:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 261              		.loc 1 332 0
 262 004a 7B68     		ldr	r3, [r7, #4]
 263 004c 5B68     		ldr	r3, [r3, #4]
 264 004e 03F48033 		and	r3, r3, #65536
 265 0052 002B     		cmp	r3, #0
 266 0054 05D0     		beq	.L12
 333:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 334:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_IT();
 267              		.loc 1 334 0
 268 0056 184A     		ldr	r2, .L17+4
 269 0058 174B     		ldr	r3, .L17+4
 270 005a 1B68     		ldr	r3, [r3]
 271 005c 43F48033 		orr	r3, r3, #65536
 272 0060 1360     		str	r3, [r2]
 273              	.L12:
 335:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 336:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 337:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure event mode */
 338:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 274              		.loc 1 338 0
 275 0062 7B68     		ldr	r3, [r7, #4]
 276 0064 5B68     		ldr	r3, [r3, #4]
 277 0066 03F40033 		and	r3, r3, #131072
 278 006a 002B     		cmp	r3, #0
 279 006c 05D0     		beq	.L13
 339:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 340:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 280              		.loc 1 340 0
 281 006e 124A     		ldr	r2, .L17+4
 282 0070 114B     		ldr	r3, .L17+4
 283 0072 5B68     		ldr	r3, [r3, #4]
 284 0074 43F48033 		orr	r3, r3, #65536
 285 0078 5360     		str	r3, [r2, #4]
 286              	.L13:
 341:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 342:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 343:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure the edge */
 344:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 287              		.loc 1 344 0
 288 007a 7B68     		ldr	r3, [r7, #4]
 289 007c 5B68     		ldr	r3, [r3, #4]
 290 007e 03F00103 		and	r3, r3, #1
 291 0082 002B     		cmp	r3, #0
 292 0084 05D0     		beq	.L14
ARM GAS  /tmp/ccKABB6j.s 			page 12


 345:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 346:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 293              		.loc 1 346 0
 294 0086 0C4A     		ldr	r2, .L17+4
 295 0088 0B4B     		ldr	r3, .L17+4
 296 008a 9B68     		ldr	r3, [r3, #8]
 297 008c 43F48033 		orr	r3, r3, #65536
 298 0090 9360     		str	r3, [r2, #8]
 299              	.L14:
 347:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 348:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 349:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 300              		.loc 1 349 0
 301 0092 7B68     		ldr	r3, [r7, #4]
 302 0094 5B68     		ldr	r3, [r3, #4]
 303 0096 03F00203 		and	r3, r3, #2
 304 009a 002B     		cmp	r3, #0
 305 009c 05D0     		beq	.L16
 350:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 351:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 306              		.loc 1 351 0
 307 009e 064A     		ldr	r2, .L17+4
 308 00a0 054B     		ldr	r3, .L17+4
 309 00a2 DB68     		ldr	r3, [r3, #12]
 310 00a4 43F48033 		orr	r3, r3, #65536
 311 00a8 D360     		str	r3, [r2, #12]
 312              	.L16:
 352:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 353:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 313              		.loc 1 353 0
 314 00aa 00BF     		nop
 315 00ac 0C37     		adds	r7, r7, #12
 316              	.LCFI19:
 317              		.cfi_def_cfa_offset 4
 318 00ae BD46     		mov	sp, r7
 319              	.LCFI20:
 320              		.cfi_def_cfa_register 13
 321              		@ sp needed
 322 00b0 80BC     		pop	{r7}
 323              	.LCFI21:
 324              		.cfi_restore 7
 325              		.cfi_def_cfa_offset 0
 326 00b2 7047     		bx	lr
 327              	.L18:
 328              		.align	2
 329              	.L17:
 330 00b4 00700040 		.word	1073770496
 331 00b8 00040140 		.word	1073808384
 332              		.cfi_endproc
 333              	.LFE69:
 335              		.section	.text.HAL_PWR_EnablePVD,"ax",%progbits
 336              		.align	1
 337              		.global	HAL_PWR_EnablePVD
 338              		.syntax unified
 339              		.thumb
 340              		.thumb_func
 341              		.fpu softvfp
ARM GAS  /tmp/ccKABB6j.s 			page 13


 343              	HAL_PWR_EnablePVD:
 344              	.LFB70:
 354:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 355:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 356:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Enables the Power Voltage Detector(PVD).
 357:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 358:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 359:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnablePVD(void)
 360:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 345              		.loc 1 360 0
 346              		.cfi_startproc
 347              		@ args = 0, pretend = 0, frame = 0
 348              		@ frame_needed = 1, uses_anonymous_args = 0
 349              		@ link register save eliminated.
 350 0000 80B4     		push	{r7}
 351              	.LCFI22:
 352              		.cfi_def_cfa_offset 4
 353              		.cfi_offset 7, -4
 354 0002 00AF     		add	r7, sp, #0
 355              	.LCFI23:
 356              		.cfi_def_cfa_register 7
 361:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable the power voltage detector */
 362:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
 357              		.loc 1 362 0
 358 0004 034B     		ldr	r3, .L20
 359 0006 0122     		movs	r2, #1
 360 0008 1A60     		str	r2, [r3]
 363:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 361              		.loc 1 363 0
 362 000a 00BF     		nop
 363 000c BD46     		mov	sp, r7
 364              	.LCFI24:
 365              		.cfi_def_cfa_register 13
 366              		@ sp needed
 367 000e 80BC     		pop	{r7}
 368              	.LCFI25:
 369              		.cfi_restore 7
 370              		.cfi_def_cfa_offset 0
 371 0010 7047     		bx	lr
 372              	.L21:
 373 0012 00BF     		.align	2
 374              	.L20:
 375 0014 10000E42 		.word	1108213776
 376              		.cfi_endproc
 377              	.LFE70:
 379              		.section	.text.HAL_PWR_DisablePVD,"ax",%progbits
 380              		.align	1
 381              		.global	HAL_PWR_DisablePVD
 382              		.syntax unified
 383              		.thumb
 384              		.thumb_func
 385              		.fpu softvfp
 387              	HAL_PWR_DisablePVD:
 388              	.LFB71:
 364:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 365:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 366:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Disables the Power Voltage Detector(PVD).
ARM GAS  /tmp/ccKABB6j.s 			page 14


 367:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 368:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 369:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisablePVD(void)
 370:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 389              		.loc 1 370 0
 390              		.cfi_startproc
 391              		@ args = 0, pretend = 0, frame = 0
 392              		@ frame_needed = 1, uses_anonymous_args = 0
 393              		@ link register save eliminated.
 394 0000 80B4     		push	{r7}
 395              	.LCFI26:
 396              		.cfi_def_cfa_offset 4
 397              		.cfi_offset 7, -4
 398 0002 00AF     		add	r7, sp, #0
 399              	.LCFI27:
 400              		.cfi_def_cfa_register 7
 371:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable the power voltage detector */
 372:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
 401              		.loc 1 372 0
 402 0004 034B     		ldr	r3, .L23
 403 0006 0022     		movs	r2, #0
 404 0008 1A60     		str	r2, [r3]
 373:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 405              		.loc 1 373 0
 406 000a 00BF     		nop
 407 000c BD46     		mov	sp, r7
 408              	.LCFI28:
 409              		.cfi_def_cfa_register 13
 410              		@ sp needed
 411 000e 80BC     		pop	{r7}
 412              	.LCFI29:
 413              		.cfi_restore 7
 414              		.cfi_def_cfa_offset 0
 415 0010 7047     		bx	lr
 416              	.L24:
 417 0012 00BF     		.align	2
 418              	.L23:
 419 0014 10000E42 		.word	1108213776
 420              		.cfi_endproc
 421              	.LFE71:
 423              		.section	.text.HAL_PWR_EnableWakeUpPin,"ax",%progbits
 424              		.align	1
 425              		.global	HAL_PWR_EnableWakeUpPin
 426              		.syntax unified
 427              		.thumb
 428              		.thumb_func
 429              		.fpu softvfp
 431              	HAL_PWR_EnableWakeUpPin:
 432              	.LFB72:
 374:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 375:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 376:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enables the WakeUp PINx functionality.
 377:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to enable.
 378:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 379:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 380:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 381:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
ARM GAS  /tmp/ccKABB6j.s 			page 15


 382:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
 383:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 433              		.loc 1 383 0
 434              		.cfi_startproc
 435              		@ args = 0, pretend = 0, frame = 16
 436              		@ frame_needed = 1, uses_anonymous_args = 0
 437              		@ link register save eliminated.
 438 0000 80B4     		push	{r7}
 439              	.LCFI30:
 440              		.cfi_def_cfa_offset 4
 441              		.cfi_offset 7, -4
 442 0002 85B0     		sub	sp, sp, #20
 443              	.LCFI31:
 444              		.cfi_def_cfa_offset 24
 445 0004 00AF     		add	r7, sp, #0
 446              	.LCFI32:
 447              		.cfi_def_cfa_register 7
 448 0006 7860     		str	r0, [r7, #4]
 449 0008 7B68     		ldr	r3, [r7, #4]
 450 000a FB60     		str	r3, [r7, #12]
 451              	.LBB6:
 452              	.LBB7:
 453              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
ARM GAS  /tmp/ccKABB6j.s 			page 16


  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
ARM GAS  /tmp/ccKABB6j.s 			page 17


  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 117:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 122:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 129:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 131:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 133:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 144:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 145:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 146:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
ARM GAS  /tmp/ccKABB6j.s 			page 18


 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 158:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 159:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 160:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 168:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 187:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
ARM GAS  /tmp/ccKABB6j.s 			page 19


 206:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 207:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 212:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 221:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 228:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 229:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 233:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 243:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 247:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 249:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 251:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
ARM GAS  /tmp/ccKABB6j.s 			page 20


 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 266:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 269:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 270:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 271:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 272:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 279:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 281:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 282:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 283:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 285:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 289:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 291:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 295:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 296:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 301:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 303:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 305:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 310:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 318:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccKABB6j.s 			page 21


 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 323:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 325:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 327:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 331:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 345:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 352:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 358:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 366:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 370:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 375:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccKABB6j.s 			page 22


 377:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 378:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 382:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 384:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 386:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 390:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 391:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 399:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 404:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 406:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 408:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 412:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 418:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 420:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 424:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 429:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 430:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 431:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
ARM GAS  /tmp/ccKABB6j.s 			page 23


 434:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 435:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 439:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 441:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 443:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 444:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 445:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 446:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 450:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 452:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 454:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 455:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 456:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 457:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 461:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 463:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 465:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 468:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 469:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 470:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 472:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 476:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 478:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 480:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 483:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 484:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 485:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 486:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 487:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccKABB6j.s 			page 24


 491:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 493:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 495:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 496:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 497:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 499:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 503:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 505:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 507:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 508:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 509:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 510:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 511:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 516:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 518:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 520:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 521:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 522:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 523:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 527:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 529:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 531:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 534:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 536:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 538:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 542:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 544:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 546:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
ARM GAS  /tmp/ccKABB6j.s 			page 25


 548:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 549:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 550:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 552:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 553:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 557:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 559:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 561:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 562:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 563:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 565:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 569:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 571:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 573:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 574:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 575:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 579:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 580:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 583:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 584:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 589:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 592:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 594:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:Drivers/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 599:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 603:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 604:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccKABB6j.s 			page 26


 605:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 607:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 611:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 614:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 616:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 620:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 624:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 625:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 626:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 627:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 628:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 629:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 634:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 637:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 639:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 644:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 646:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 647:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 648:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 649:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 651:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 655:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 658:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 660:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
ARM GAS  /tmp/ccKABB6j.s 			page 27


 662:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 664:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 666:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 667:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 668:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 669:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 670:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 671:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 676:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 679:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 681:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 686:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 690:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 691:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 692:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 693:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 695:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 699:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 702:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 704:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 708:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 712:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 713:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 714:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 715:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 716:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 717:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
ARM GAS  /tmp/ccKABB6j.s 			page 28


 719:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 722:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 725:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 727:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 732:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 734:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 735:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 736:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 737:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 739:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 743:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 746:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 748:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 752:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 754:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 755:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 756:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 757:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 760:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 761:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 762:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 766:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 768:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
ARM GAS  /tmp/ccKABB6j.s 			page 29


 776:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 778:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 781:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 782:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 784:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 785:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 786:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 787:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 788:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 792:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 794:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:Drivers/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 802:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 804:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 805:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 807:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 808:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 809:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 810:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 812:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 813:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 817:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 818:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 819:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 827:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 831:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 832:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccKABB6j.s 			page 30


 833:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 836:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 838:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 839:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 842:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 844:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 845:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 846:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 850:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 852:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 853:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 854:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 857:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 859:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 860:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 861:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 866:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 868:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 870:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 871:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 872:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 873:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 877:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 879:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 881:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 882:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 883:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 884:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:Drivers/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 888:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccKABB6j.s 			page 31


 890:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 892:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 893:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 894:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 895:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 900:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 902:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 905:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 907:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 910:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 911:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 912:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 913:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 914:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 919:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 921:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 923:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 926:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 927:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 928:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 929:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 934:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 936:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 939:Drivers/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 940:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 941:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 942:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 943:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 944:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 945:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 946:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccKABB6j.s 			page 32


 947:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 948:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 953:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 954:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 956:Drivers/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 957:Drivers/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 958:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 959:Drivers/CMSIS/Include/cmsis_gcc.h ****     return op1;
 960:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 961:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 963:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 964:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 965:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 966:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 967:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:Drivers/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:Drivers/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 972:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 974:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 975:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 976:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 979:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 980:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 981:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 983:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 984:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 985:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 454              		.loc 2 988 0
 455 000c FB68     		ldr	r3, [r7, #12]
 456              		.syntax unified
 457              	@ 988 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 458 000e 93FAA3F3 		rbit r3, r3
 459              	@ 0 "" 2
 460              		.thumb
 461              		.syntax unified
 462 0012 BB60     		str	r3, [r7, #8]
 989:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 990:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
 991:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 992:Drivers/CMSIS/Include/cmsis_gcc.h ****   result = value;                      /* r will be reversed bits of v; first get LSB of v */
 993:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (value >>= 1U; value != 0U; value >>= 1U)
 994:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
ARM GAS  /tmp/ccKABB6j.s 			page 33


 995:Drivers/CMSIS/Include/cmsis_gcc.h ****     result <<= 1U;
 996:Drivers/CMSIS/Include/cmsis_gcc.h ****     result |= value & 1U;
 997:Drivers/CMSIS/Include/cmsis_gcc.h ****     s--;
 998:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 999:Drivers/CMSIS/Include/cmsis_gcc.h ****   result <<= s;                        /* shift when v's highest bits are zero */
1000:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
1001:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 463              		.loc 2 1001 0
 464 0014 BB68     		ldr	r3, [r7, #8]
 465              	.LBE7:
 466              	.LBE6:
 384:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
 385:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 386:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable the EWUPx pin */
 387:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
 467              		.loc 1 387 0
 468 0016 B3FA83F3 		clz	r3, r3
 469 001a DBB2     		uxtb	r3, r3
 470 001c 1A46     		mov	r2, r3
 471 001e 054B     		ldr	r3, .L27
 472 0020 1344     		add	r3, r3, r2
 473 0022 9B00     		lsls	r3, r3, #2
 474 0024 1A46     		mov	r2, r3
 475 0026 0123     		movs	r3, #1
 476 0028 1360     		str	r3, [r2]
 388:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 477              		.loc 1 388 0
 478 002a 00BF     		nop
 479 002c 1437     		adds	r7, r7, #20
 480              	.LCFI33:
 481              		.cfi_def_cfa_offset 4
 482 002e BD46     		mov	sp, r7
 483              	.LCFI34:
 484              		.cfi_def_cfa_register 13
 485              		@ sp needed
 486 0030 80BC     		pop	{r7}
 487              	.LCFI35:
 488              		.cfi_restore 7
 489              		.cfi_def_cfa_offset 0
 490 0032 7047     		bx	lr
 491              	.L28:
 492              		.align	2
 493              	.L27:
 494 0034 20808310 		.word	277053472
 495              		.cfi_endproc
 496              	.LFE72:
 498              		.section	.text.HAL_PWR_DisableWakeUpPin,"ax",%progbits
 499              		.align	1
 500              		.global	HAL_PWR_DisableWakeUpPin
 501              		.syntax unified
 502              		.thumb
 503              		.thumb_func
 504              		.fpu softvfp
 506              	HAL_PWR_DisableWakeUpPin:
 507              	.LFB73:
 389:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 390:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
ARM GAS  /tmp/ccKABB6j.s 			page 34


 391:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables the WakeUp PINx functionality.
 392:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
 393:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 394:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 395:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 396:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 397:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
 398:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 508              		.loc 1 398 0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 16
 511              		@ frame_needed = 1, uses_anonymous_args = 0
 512              		@ link register save eliminated.
 513 0000 80B4     		push	{r7}
 514              	.LCFI36:
 515              		.cfi_def_cfa_offset 4
 516              		.cfi_offset 7, -4
 517 0002 85B0     		sub	sp, sp, #20
 518              	.LCFI37:
 519              		.cfi_def_cfa_offset 24
 520 0004 00AF     		add	r7, sp, #0
 521              	.LCFI38:
 522              		.cfi_def_cfa_register 7
 523 0006 7860     		str	r0, [r7, #4]
 524 0008 7B68     		ldr	r3, [r7, #4]
 525 000a FB60     		str	r3, [r7, #12]
 526              	.LBB8:
 527              	.LBB9:
 988:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 528              		.loc 2 988 0
 529 000c FB68     		ldr	r3, [r7, #12]
 530              		.syntax unified
 531              	@ 988 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 532 000e 93FAA3F3 		rbit r3, r3
 533              	@ 0 "" 2
 534              		.thumb
 535              		.syntax unified
 536 0012 BB60     		str	r3, [r7, #8]
 537              		.loc 2 1001 0
 538 0014 BB68     		ldr	r3, [r7, #8]
 539              	.LBE9:
 540              	.LBE8:
 399:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
 400:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 401:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable the EWUPx pin */
 402:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
 541              		.loc 1 402 0
 542 0016 B3FA83F3 		clz	r3, r3
 543 001a DBB2     		uxtb	r3, r3
 544 001c 1A46     		mov	r2, r3
 545 001e 054B     		ldr	r3, .L31
 546 0020 1344     		add	r3, r3, r2
 547 0022 9B00     		lsls	r3, r3, #2
 548 0024 1A46     		mov	r2, r3
 549 0026 0023     		movs	r3, #0
 550 0028 1360     		str	r3, [r2]
 403:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
ARM GAS  /tmp/ccKABB6j.s 			page 35


 551              		.loc 1 403 0
 552 002a 00BF     		nop
 553 002c 1437     		adds	r7, r7, #20
 554              	.LCFI39:
 555              		.cfi_def_cfa_offset 4
 556 002e BD46     		mov	sp, r7
 557              	.LCFI40:
 558              		.cfi_def_cfa_register 13
 559              		@ sp needed
 560 0030 80BC     		pop	{r7}
 561              	.LCFI41:
 562              		.cfi_restore 7
 563              		.cfi_def_cfa_offset 0
 564 0032 7047     		bx	lr
 565              	.L32:
 566              		.align	2
 567              	.L31:
 568 0034 20808310 		.word	277053472
 569              		.cfi_endproc
 570              	.LFE73:
 572              		.section	.text.HAL_PWR_EnterSLEEPMode,"ax",%progbits
 573              		.align	1
 574              		.global	HAL_PWR_EnterSLEEPMode
 575              		.syntax unified
 576              		.thumb
 577              		.thumb_func
 578              		.fpu softvfp
 580              	HAL_PWR_EnterSLEEPMode:
 581              	.LFB74:
 404:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 405:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 406:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Sleep mode.
 407:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
 408:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Regulator state as no effect in SLEEP mode -  allows to support portability f
 409:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param SLEEPEntry: Specifies if SLEEP mode is entered with WFI or WFE instruction.
 410:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           When WFI entry is used, tick interrupt have to be disabled if not desired as 
 411:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           the interrupt wake up source.
 412:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           This parameter can be one of the following values:
 413:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 414:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 415:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 416:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 417:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
 418:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 582              		.loc 1 418 0
 583              		.cfi_startproc
 584              		@ args = 0, pretend = 0, frame = 8
 585              		@ frame_needed = 1, uses_anonymous_args = 0
 586              		@ link register save eliminated.
 587 0000 80B4     		push	{r7}
 588              	.LCFI42:
 589              		.cfi_def_cfa_offset 4
 590              		.cfi_offset 7, -4
 591 0002 83B0     		sub	sp, sp, #12
 592              	.LCFI43:
 593              		.cfi_def_cfa_offset 16
 594 0004 00AF     		add	r7, sp, #0
ARM GAS  /tmp/ccKABB6j.s 			page 36


 595              	.LCFI44:
 596              		.cfi_def_cfa_register 7
 597 0006 7860     		str	r0, [r7, #4]
 598 0008 0B46     		mov	r3, r1
 599 000a FB70     		strb	r3, [r7, #3]
 419:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 420:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* No check on Regulator because parameter not used in SLEEP mode */
 421:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Prevent unused argument(s) compilation warning */
 422:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   UNUSED(Regulator);
 423:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 424:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
 425:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 426:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 427:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 600              		.loc 1 427 0
 601 000c 094A     		ldr	r2, .L37
 602 000e 094B     		ldr	r3, .L37
 603 0010 1B69     		ldr	r3, [r3, #16]
 604 0012 23F00403 		bic	r3, r3, #4
 605 0016 1361     		str	r3, [r2, #16]
 428:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 429:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 430:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 606              		.loc 1 430 0
 607 0018 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 608 001a 012B     		cmp	r3, #1
 609 001c 01D1     		bne	.L34
 431:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 432:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 433:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFI();
 610              		.loc 1 433 0
 611              		.syntax unified
 612              	@ 433 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 613 001e 30BF     		wfi
 614              	@ 0 "" 2
 434:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 435:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   else
 436:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 437:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 438:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __SEV();
 439:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 440:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 441:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 442:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 615              		.loc 1 442 0
 616              		.thumb
 617              		.syntax unified
 618 0020 02E0     		b	.L36
 619              	.L34:
 438:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 620              		.loc 1 438 0
 621              		.syntax unified
 622              	@ 438 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 623 0022 40BF     		sev
 624              	@ 0 "" 2
 439:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 625              		.loc 1 439 0
ARM GAS  /tmp/ccKABB6j.s 			page 37


 626              	@ 439 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 627 0024 20BF     		wfe
 628              	@ 0 "" 2
 440:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 629              		.loc 1 440 0
 630              	@ 440 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 631 0026 20BF     		wfe
 632              	@ 0 "" 2
 633              		.thumb
 634              		.syntax unified
 635              	.L36:
 636              		.loc 1 442 0
 637 0028 00BF     		nop
 638 002a 0C37     		adds	r7, r7, #12
 639              	.LCFI45:
 640              		.cfi_def_cfa_offset 4
 641 002c BD46     		mov	sp, r7
 642              	.LCFI46:
 643              		.cfi_def_cfa_register 13
 644              		@ sp needed
 645 002e 80BC     		pop	{r7}
 646              	.LCFI47:
 647              		.cfi_restore 7
 648              		.cfi_def_cfa_offset 0
 649 0030 7047     		bx	lr
 650              	.L38:
 651 0032 00BF     		.align	2
 652              	.L37:
 653 0034 00ED00E0 		.word	-536810240
 654              		.cfi_endproc
 655              	.LFE74:
 657              		.section	.text.HAL_PWR_EnterSTOPMode,"ax",%progbits
 658              		.align	1
 659              		.global	HAL_PWR_EnterSTOPMode
 660              		.syntax unified
 661              		.thumb
 662              		.thumb_func
 663              		.fpu softvfp
 665              	HAL_PWR_EnterSTOPMode:
 666              	.LFB75:
 443:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 444:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 445:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Stop mode. 
 446:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
 447:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  When exiting Stop mode by using an interrupt or a wakeup event,
 448:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        HSI RC oscillator is selected as system clock.
 449:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  When the voltage regulator operates in low power mode, an additional
 450:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 451:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption
 452:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         is higher although the startup time is reduced.    
 453:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Specifies the regulator state in Stop mode.
 454:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 455:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
 456:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
 457:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
 458:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 459:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
ARM GAS  /tmp/ccKABB6j.s 			page 38


 460:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction   
 461:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 462:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 463:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 464:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 667              		.loc 1 464 0
 668              		.cfi_startproc
 669              		@ args = 0, pretend = 0, frame = 8
 670              		@ frame_needed = 1, uses_anonymous_args = 0
 671 0000 80B5     		push	{r7, lr}
 672              	.LCFI48:
 673              		.cfi_def_cfa_offset 8
 674              		.cfi_offset 7, -8
 675              		.cfi_offset 14, -4
 676 0002 82B0     		sub	sp, sp, #8
 677              	.LCFI49:
 678              		.cfi_def_cfa_offset 16
 679 0004 00AF     		add	r7, sp, #0
 680              	.LCFI50:
 681              		.cfi_def_cfa_register 7
 682 0006 7860     		str	r0, [r7, #4]
 683 0008 0B46     		mov	r3, r1
 684 000a FB70     		strb	r3, [r7, #3]
 465:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 466:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 467:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 468:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 469:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */
 470:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);
 685              		.loc 1 470 0
 686 000c 134A     		ldr	r2, .L42
 687 000e 134B     		ldr	r3, .L42
 688 0010 1B68     		ldr	r3, [r3]
 689 0012 23F00203 		bic	r3, r3, #2
 690 0016 1360     		str	r3, [r2]
 471:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 472:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator p
 473:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
 691              		.loc 1 473 0
 692 0018 1049     		ldr	r1, .L42
 693 001a 104B     		ldr	r3, .L42
 694 001c 1B68     		ldr	r3, [r3]
 695 001e 23F00102 		bic	r2, r3, #1
 696 0022 7B68     		ldr	r3, [r7, #4]
 697 0024 1343     		orrs	r3, r3, r2
 698 0026 0B60     		str	r3, [r1]
 474:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 475:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 476:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 699              		.loc 1 476 0
 700 0028 0D4A     		ldr	r2, .L42+4
 701 002a 0D4B     		ldr	r3, .L42+4
 702 002c 1B69     		ldr	r3, [r3, #16]
 703 002e 43F00403 		orr	r3, r3, #4
 704 0032 1361     		str	r3, [r2, #16]
 477:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 478:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select Stop mode entry --------------------------------------------------*/
ARM GAS  /tmp/ccKABB6j.s 			page 39


 479:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 705              		.loc 1 479 0
 706 0034 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 707 0036 012B     		cmp	r3, #1
 708 0038 01D1     		bne	.L40
 480:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 481:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 482:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFI();
 709              		.loc 1 482 0
 710              		.syntax unified
 711              	@ 482 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 712 003a 30BF     		wfi
 713              	@ 0 "" 2
 714              		.thumb
 715              		.syntax unified
 716 003c 04E0     		b	.L41
 717              	.L40:
 483:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 484:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   else
 485:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 486:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 487:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __SEV();
 718              		.loc 1 487 0
 719              		.syntax unified
 720              	@ 487 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 721 003e 40BF     		sev
 722              	@ 0 "" 2
 488:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 723              		.loc 1 488 0
 724              		.thumb
 725              		.syntax unified
 726 0040 FFF7FEFF 		bl	PWR_OverloadWfe
 489:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 727              		.loc 1 489 0
 728 0044 FFF7FEFF 		bl	PWR_OverloadWfe
 729              	.L41:
 490:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 491:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 492:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 730              		.loc 1 492 0
 731 0048 054A     		ldr	r2, .L42+4
 732 004a 054B     		ldr	r3, .L42+4
 733 004c 1B69     		ldr	r3, [r3, #16]
 734 004e 23F00403 		bic	r3, r3, #4
 735 0052 1361     		str	r3, [r2, #16]
 493:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 736              		.loc 1 493 0
 737 0054 00BF     		nop
 738 0056 0837     		adds	r7, r7, #8
 739              	.LCFI51:
 740              		.cfi_def_cfa_offset 8
 741 0058 BD46     		mov	sp, r7
 742              	.LCFI52:
 743              		.cfi_def_cfa_register 13
 744              		@ sp needed
 745 005a 80BD     		pop	{r7, pc}
 746              	.L43:
ARM GAS  /tmp/ccKABB6j.s 			page 40


 747              		.align	2
 748              	.L42:
 749 005c 00700040 		.word	1073770496
 750 0060 00ED00E0 		.word	-536810240
 751              		.cfi_endproc
 752              	.LFE75:
 754              		.section	.text.HAL_PWR_EnterSTANDBYMode,"ax",%progbits
 755              		.align	1
 756              		.global	HAL_PWR_EnterSTANDBYMode
 757              		.syntax unified
 758              		.thumb
 759              		.thumb_func
 760              		.fpu softvfp
 762              	HAL_PWR_EnterSTANDBYMode:
 763              	.LFB76:
 494:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 495:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 496:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Standby mode.
 497:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Standby mode, all I/O pins are high impedance except for:
 498:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - Reset pad (still available) 
 499:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - TAMPER pin if configured for tamper or calibration out.
 500:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - WKUP pin (PA0) if enabled.
 501:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 502:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 503:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTANDBYMode(void)
 504:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 764              		.loc 1 504 0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 0
 767              		@ frame_needed = 1, uses_anonymous_args = 0
 768              		@ link register save eliminated.
 769 0000 80B4     		push	{r7}
 770              	.LCFI53:
 771              		.cfi_def_cfa_offset 4
 772              		.cfi_offset 7, -4
 773 0002 00AF     		add	r7, sp, #0
 774              	.LCFI54:
 775              		.cfi_def_cfa_register 7
 505:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select Standby mode */
 506:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(PWR->CR, PWR_CR_PDDS);
 776              		.loc 1 506 0
 777 0004 084A     		ldr	r2, .L45
 778 0006 084B     		ldr	r3, .L45
 779 0008 1B68     		ldr	r3, [r3]
 780 000a 43F00203 		orr	r3, r3, #2
 781 000e 1360     		str	r3, [r2]
 507:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 508:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 509:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 782              		.loc 1 509 0
 783 0010 064A     		ldr	r2, .L45+4
 784 0012 064B     		ldr	r3, .L45+4
 785 0014 1B69     		ldr	r3, [r3, #16]
 786 0016 43F00403 		orr	r3, r3, #4
 787 001a 1361     		str	r3, [r2, #16]
 510:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 511:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* This option is used to ensure that store operations are completed */
ARM GAS  /tmp/ccKABB6j.s 			page 41


 512:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #if defined ( __CC_ARM)
 513:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __force_stores();
 514:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #endif
 515:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Request Wait For Interrupt */
 516:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __WFI();
 788              		.loc 1 516 0
 789              		.syntax unified
 790              	@ 516 "Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 791 001c 30BF     		wfi
 792              	@ 0 "" 2
 517:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 793              		.loc 1 517 0
 794              		.thumb
 795              		.syntax unified
 796 001e 00BF     		nop
 797 0020 BD46     		mov	sp, r7
 798              	.LCFI55:
 799              		.cfi_def_cfa_register 13
 800              		@ sp needed
 801 0022 80BC     		pop	{r7}
 802              	.LCFI56:
 803              		.cfi_restore 7
 804              		.cfi_def_cfa_offset 0
 805 0024 7047     		bx	lr
 806              	.L46:
 807 0026 00BF     		.align	2
 808              	.L45:
 809 0028 00700040 		.word	1073770496
 810 002c 00ED00E0 		.word	-536810240
 811              		.cfi_endproc
 812              	.LFE76:
 814              		.section	.text.HAL_PWR_EnableSleepOnExit,"ax",%progbits
 815              		.align	1
 816              		.global	HAL_PWR_EnableSleepOnExit
 817              		.syntax unified
 818              		.thumb
 819              		.thumb_func
 820              		.fpu softvfp
 822              	HAL_PWR_EnableSleepOnExit:
 823              	.LFB77:
 518:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 519:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 520:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 521:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
 522:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 523:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.
 524:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       Setting this bit is useful when the processor is expected to run only on
 525:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       interruptions handling.         
 526:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 527:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 528:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 529:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 824              		.loc 1 529 0
 825              		.cfi_startproc
 826              		@ args = 0, pretend = 0, frame = 0
 827              		@ frame_needed = 1, uses_anonymous_args = 0
 828              		@ link register save eliminated.
ARM GAS  /tmp/ccKABB6j.s 			page 42


 829 0000 80B4     		push	{r7}
 830              	.LCFI57:
 831              		.cfi_def_cfa_offset 4
 832              		.cfi_offset 7, -4
 833 0002 00AF     		add	r7, sp, #0
 834              	.LCFI58:
 835              		.cfi_def_cfa_register 7
 530:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 531:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 836              		.loc 1 531 0
 837 0004 044A     		ldr	r2, .L48
 838 0006 044B     		ldr	r3, .L48
 839 0008 1B69     		ldr	r3, [r3, #16]
 840 000a 43F00203 		orr	r3, r3, #2
 841 000e 1361     		str	r3, [r2, #16]
 532:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 842              		.loc 1 532 0
 843 0010 00BF     		nop
 844 0012 BD46     		mov	sp, r7
 845              	.LCFI59:
 846              		.cfi_def_cfa_register 13
 847              		@ sp needed
 848 0014 80BC     		pop	{r7}
 849              	.LCFI60:
 850              		.cfi_restore 7
 851              		.cfi_def_cfa_offset 0
 852 0016 7047     		bx	lr
 853              	.L49:
 854              		.align	2
 855              	.L48:
 856 0018 00ED00E0 		.word	-536810240
 857              		.cfi_endproc
 858              	.LFE77:
 860              		.section	.text.HAL_PWR_DisableSleepOnExit,"ax",%progbits
 861              		.align	1
 862              		.global	HAL_PWR_DisableSleepOnExit
 863              		.syntax unified
 864              		.thumb
 865              		.thumb_func
 866              		.fpu softvfp
 868              	HAL_PWR_DisableSleepOnExit:
 869              	.LFB78:
 533:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 534:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 535:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 536:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
 537:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 538:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.          
 539:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 540:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 541:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 542:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 870              		.loc 1 542 0
 871              		.cfi_startproc
 872              		@ args = 0, pretend = 0, frame = 0
 873              		@ frame_needed = 1, uses_anonymous_args = 0
 874              		@ link register save eliminated.
ARM GAS  /tmp/ccKABB6j.s 			page 43


 875 0000 80B4     		push	{r7}
 876              	.LCFI61:
 877              		.cfi_def_cfa_offset 4
 878              		.cfi_offset 7, -4
 879 0002 00AF     		add	r7, sp, #0
 880              	.LCFI62:
 881              		.cfi_def_cfa_register 7
 543:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 544:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 882              		.loc 1 544 0
 883 0004 044A     		ldr	r2, .L51
 884 0006 044B     		ldr	r3, .L51
 885 0008 1B69     		ldr	r3, [r3, #16]
 886 000a 23F00203 		bic	r3, r3, #2
 887 000e 1361     		str	r3, [r2, #16]
 545:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 888              		.loc 1 545 0
 889 0010 00BF     		nop
 890 0012 BD46     		mov	sp, r7
 891              	.LCFI63:
 892              		.cfi_def_cfa_register 13
 893              		@ sp needed
 894 0014 80BC     		pop	{r7}
 895              	.LCFI64:
 896              		.cfi_restore 7
 897              		.cfi_def_cfa_offset 0
 898 0016 7047     		bx	lr
 899              	.L52:
 900              		.align	2
 901              	.L51:
 902 0018 00ED00E0 		.word	-536810240
 903              		.cfi_endproc
 904              	.LFE78:
 906              		.section	.text.HAL_PWR_EnableSEVOnPend,"ax",%progbits
 907              		.align	1
 908              		.global	HAL_PWR_EnableSEVOnPend
 909              		.syntax unified
 910              		.thumb
 911              		.thumb_func
 912              		.fpu softvfp
 914              	HAL_PWR_EnableSEVOnPend:
 915              	.LFB79:
 546:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 547:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 548:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 549:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enables CORTEX M3 SEVONPEND bit. 
 550:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
 551:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.
 552:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 553:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 554:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 555:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 916              		.loc 1 555 0
 917              		.cfi_startproc
 918              		@ args = 0, pretend = 0, frame = 0
 919              		@ frame_needed = 1, uses_anonymous_args = 0
 920              		@ link register save eliminated.
ARM GAS  /tmp/ccKABB6j.s 			page 44


 921 0000 80B4     		push	{r7}
 922              	.LCFI65:
 923              		.cfi_def_cfa_offset 4
 924              		.cfi_offset 7, -4
 925 0002 00AF     		add	r7, sp, #0
 926              	.LCFI66:
 927              		.cfi_def_cfa_register 7
 556:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 557:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 928              		.loc 1 557 0
 929 0004 044A     		ldr	r2, .L54
 930 0006 044B     		ldr	r3, .L54
 931 0008 1B69     		ldr	r3, [r3, #16]
 932 000a 43F01003 		orr	r3, r3, #16
 933 000e 1361     		str	r3, [r2, #16]
 558:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 934              		.loc 1 558 0
 935 0010 00BF     		nop
 936 0012 BD46     		mov	sp, r7
 937              	.LCFI67:
 938              		.cfi_def_cfa_register 13
 939              		@ sp needed
 940 0014 80BC     		pop	{r7}
 941              	.LCFI68:
 942              		.cfi_restore 7
 943              		.cfi_def_cfa_offset 0
 944 0016 7047     		bx	lr
 945              	.L55:
 946              		.align	2
 947              	.L54:
 948 0018 00ED00E0 		.word	-536810240
 949              		.cfi_endproc
 950              	.LFE79:
 952              		.section	.text.HAL_PWR_DisableSEVOnPend,"ax",%progbits
 953              		.align	1
 954              		.global	HAL_PWR_DisableSEVOnPend
 955              		.syntax unified
 956              		.thumb
 957              		.thumb_func
 958              		.fpu softvfp
 960              	HAL_PWR_DisableSEVOnPend:
 961              	.LFB80:
 559:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 560:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 561:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 562:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables CORTEX M3 SEVONPEND bit. 
 563:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
 564:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.         
 565:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 566:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 567:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 568:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 962              		.loc 1 568 0
 963              		.cfi_startproc
 964              		@ args = 0, pretend = 0, frame = 0
 965              		@ frame_needed = 1, uses_anonymous_args = 0
 966              		@ link register save eliminated.
ARM GAS  /tmp/ccKABB6j.s 			page 45


 967 0000 80B4     		push	{r7}
 968              	.LCFI69:
 969              		.cfi_def_cfa_offset 4
 970              		.cfi_offset 7, -4
 971 0002 00AF     		add	r7, sp, #0
 972              	.LCFI70:
 973              		.cfi_def_cfa_register 7
 569:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 570:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 974              		.loc 1 570 0
 975 0004 044A     		ldr	r2, .L57
 976 0006 044B     		ldr	r3, .L57
 977 0008 1B69     		ldr	r3, [r3, #16]
 978 000a 23F01003 		bic	r3, r3, #16
 979 000e 1361     		str	r3, [r2, #16]
 571:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 980              		.loc 1 571 0
 981 0010 00BF     		nop
 982 0012 BD46     		mov	sp, r7
 983              	.LCFI71:
 984              		.cfi_def_cfa_register 13
 985              		@ sp needed
 986 0014 80BC     		pop	{r7}
 987              	.LCFI72:
 988              		.cfi_restore 7
 989              		.cfi_def_cfa_offset 0
 990 0016 7047     		bx	lr
 991              	.L58:
 992              		.align	2
 993              	.L57:
 994 0018 00ED00E0 		.word	-536810240
 995              		.cfi_endproc
 996              	.LFE80:
 998              		.section	.text.HAL_PWR_PVD_IRQHandler,"ax",%progbits
 999              		.align	1
 1000              		.global	HAL_PWR_PVD_IRQHandler
 1001              		.syntax unified
 1002              		.thumb
 1003              		.thumb_func
 1004              		.fpu softvfp
 1006              	HAL_PWR_PVD_IRQHandler:
 1007              	.LFB81:
 572:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 573:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 574:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 575:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 576:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  This function handles the PWR PVD interrupt request.
 577:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   This API should be called under the PVD_IRQHandler().
 578:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 579:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 580:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_PVD_IRQHandler(void)
 581:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 1008              		.loc 1 581 0
 1009              		.cfi_startproc
 1010              		@ args = 0, pretend = 0, frame = 0
 1011              		@ frame_needed = 1, uses_anonymous_args = 0
 1012 0000 80B5     		push	{r7, lr}
ARM GAS  /tmp/ccKABB6j.s 			page 46


 1013              	.LCFI73:
 1014              		.cfi_def_cfa_offset 8
 1015              		.cfi_offset 7, -8
 1016              		.cfi_offset 14, -4
 1017 0002 00AF     		add	r7, sp, #0
 1018              	.LCFI74:
 1019              		.cfi_def_cfa_register 7
 582:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check PWR exti flag */
 583:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 1020              		.loc 1 583 0
 1021 0004 064B     		ldr	r3, .L62
 1022 0006 5B69     		ldr	r3, [r3, #20]
 1023 0008 03F48033 		and	r3, r3, #65536
 1024 000c 002B     		cmp	r3, #0
 1025 000e 05D0     		beq	.L61
 584:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 585:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* PWR PVD interrupt user callback */
 586:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     HAL_PWR_PVDCallback();
 1026              		.loc 1 586 0
 1027 0010 FFF7FEFF 		bl	HAL_PWR_PVDCallback
 587:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 588:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Clear PWR Exti pending bit */
 589:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 1028              		.loc 1 589 0
 1029 0014 024B     		ldr	r3, .L62
 1030 0016 4FF48032 		mov	r2, #65536
 1031 001a 5A61     		str	r2, [r3, #20]
 1032              	.L61:
 590:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 591:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 1033              		.loc 1 591 0
 1034 001c 00BF     		nop
 1035 001e 80BD     		pop	{r7, pc}
 1036              	.L63:
 1037              		.align	2
 1038              	.L62:
 1039 0020 00040140 		.word	1073808384
 1040              		.cfi_endproc
 1041              	.LFE81:
 1043              		.section	.text.HAL_PWR_PVDCallback,"ax",%progbits
 1044              		.align	1
 1045              		.weak	HAL_PWR_PVDCallback
 1046              		.syntax unified
 1047              		.thumb
 1048              		.thumb_func
 1049              		.fpu softvfp
 1051              	HAL_PWR_PVDCallback:
 1052              	.LFB82:
 592:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 593:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 594:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  PWR PVD interrupt callback
 595:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 596:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 597:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** __weak void HAL_PWR_PVDCallback(void)
 598:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 1053              		.loc 1 598 0
 1054              		.cfi_startproc
ARM GAS  /tmp/ccKABB6j.s 			page 47


 1055              		@ args = 0, pretend = 0, frame = 0
 1056              		@ frame_needed = 1, uses_anonymous_args = 0
 1057              		@ link register save eliminated.
 1058 0000 80B4     		push	{r7}
 1059              	.LCFI75:
 1060              		.cfi_def_cfa_offset 4
 1061              		.cfi_offset 7, -4
 1062 0002 00AF     		add	r7, sp, #0
 1063              	.LCFI76:
 1064              		.cfi_def_cfa_register 7
 599:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* NOTE : This function Should not be modified, when the callback is needed,
 600:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****             the HAL_PWR_PVDCallback could be implemented in the user file
 601:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    */ 
 602:Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 1065              		.loc 1 602 0
 1066 0004 00BF     		nop
 1067 0006 BD46     		mov	sp, r7
 1068              	.LCFI77:
 1069              		.cfi_def_cfa_register 13
 1070              		@ sp needed
 1071 0008 80BC     		pop	{r7}
 1072              	.LCFI78:
 1073              		.cfi_restore 7
 1074              		.cfi_def_cfa_offset 0
 1075 000a 7047     		bx	lr
 1076              		.cfi_endproc
 1077              	.LFE82:
 1079              		.text
 1080              	.Letext0:
 1081              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 1082              		.file 4 "/usr/include/newlib/sys/_stdint.h"
 1083              		.file 5 "Drivers/CMSIS/Include/core_cm3.h"
 1084              		.file 6 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 1085              		.file 7 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 1086              		.file 8 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
 1087              		.file 9 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_pwr.h"
 1088              		.file 10 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
ARM GAS  /tmp/ccKABB6j.s 			page 48


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f1xx_hal_pwr.c
     /tmp/ccKABB6j.s:16     .text.PWR_OverloadWfe:0000000000000000 $t
     /tmp/ccKABB6j.s:22     .text.PWR_OverloadWfe:0000000000000000 PWR_OverloadWfe
     /tmp/ccKABB6j.s:63     .text.HAL_PWR_DeInit:0000000000000000 $t
     /tmp/ccKABB6j.s:70     .text.HAL_PWR_DeInit:0000000000000000 HAL_PWR_DeInit
     /tmp/ccKABB6j.s:110    .text.HAL_PWR_DeInit:0000000000000024 $d
     /tmp/ccKABB6j.s:115    .text.HAL_PWR_EnableBkUpAccess:0000000000000000 $t
     /tmp/ccKABB6j.s:122    .text.HAL_PWR_EnableBkUpAccess:0000000000000000 HAL_PWR_EnableBkUpAccess
     /tmp/ccKABB6j.s:154    .text.HAL_PWR_EnableBkUpAccess:0000000000000014 $d
     /tmp/ccKABB6j.s:159    .text.HAL_PWR_DisableBkUpAccess:0000000000000000 $t
     /tmp/ccKABB6j.s:166    .text.HAL_PWR_DisableBkUpAccess:0000000000000000 HAL_PWR_DisableBkUpAccess
     /tmp/ccKABB6j.s:198    .text.HAL_PWR_DisableBkUpAccess:0000000000000014 $d
     /tmp/ccKABB6j.s:203    .text.HAL_PWR_ConfigPVD:0000000000000000 $t
     /tmp/ccKABB6j.s:210    .text.HAL_PWR_ConfigPVD:0000000000000000 HAL_PWR_ConfigPVD
     /tmp/ccKABB6j.s:330    .text.HAL_PWR_ConfigPVD:00000000000000b4 $d
     /tmp/ccKABB6j.s:336    .text.HAL_PWR_EnablePVD:0000000000000000 $t
     /tmp/ccKABB6j.s:343    .text.HAL_PWR_EnablePVD:0000000000000000 HAL_PWR_EnablePVD
     /tmp/ccKABB6j.s:375    .text.HAL_PWR_EnablePVD:0000000000000014 $d
     /tmp/ccKABB6j.s:380    .text.HAL_PWR_DisablePVD:0000000000000000 $t
     /tmp/ccKABB6j.s:387    .text.HAL_PWR_DisablePVD:0000000000000000 HAL_PWR_DisablePVD
     /tmp/ccKABB6j.s:419    .text.HAL_PWR_DisablePVD:0000000000000014 $d
     /tmp/ccKABB6j.s:424    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 $t
     /tmp/ccKABB6j.s:431    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 HAL_PWR_EnableWakeUpPin
     /tmp/ccKABB6j.s:494    .text.HAL_PWR_EnableWakeUpPin:0000000000000034 $d
     /tmp/ccKABB6j.s:499    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 $t
     /tmp/ccKABB6j.s:506    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 HAL_PWR_DisableWakeUpPin
     /tmp/ccKABB6j.s:568    .text.HAL_PWR_DisableWakeUpPin:0000000000000034 $d
     /tmp/ccKABB6j.s:573    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 $t
     /tmp/ccKABB6j.s:580    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 HAL_PWR_EnterSLEEPMode
     /tmp/ccKABB6j.s:653    .text.HAL_PWR_EnterSLEEPMode:0000000000000034 $d
     /tmp/ccKABB6j.s:658    .text.HAL_PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/ccKABB6j.s:665    .text.HAL_PWR_EnterSTOPMode:0000000000000000 HAL_PWR_EnterSTOPMode
     /tmp/ccKABB6j.s:749    .text.HAL_PWR_EnterSTOPMode:000000000000005c $d
     /tmp/ccKABB6j.s:755    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/ccKABB6j.s:762    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 HAL_PWR_EnterSTANDBYMode
     /tmp/ccKABB6j.s:809    .text.HAL_PWR_EnterSTANDBYMode:0000000000000028 $d
     /tmp/ccKABB6j.s:815    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 $t
     /tmp/ccKABB6j.s:822    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 HAL_PWR_EnableSleepOnExit
     /tmp/ccKABB6j.s:856    .text.HAL_PWR_EnableSleepOnExit:0000000000000018 $d
     /tmp/ccKABB6j.s:861    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 $t
     /tmp/ccKABB6j.s:868    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 HAL_PWR_DisableSleepOnExit
     /tmp/ccKABB6j.s:902    .text.HAL_PWR_DisableSleepOnExit:0000000000000018 $d
     /tmp/ccKABB6j.s:907    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 $t
     /tmp/ccKABB6j.s:914    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 HAL_PWR_EnableSEVOnPend
     /tmp/ccKABB6j.s:948    .text.HAL_PWR_EnableSEVOnPend:0000000000000018 $d
     /tmp/ccKABB6j.s:953    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 $t
     /tmp/ccKABB6j.s:960    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 HAL_PWR_DisableSEVOnPend
     /tmp/ccKABB6j.s:994    .text.HAL_PWR_DisableSEVOnPend:0000000000000018 $d
     /tmp/ccKABB6j.s:999    .text.HAL_PWR_PVD_IRQHandler:0000000000000000 $t
     /tmp/ccKABB6j.s:1006   .text.HAL_PWR_PVD_IRQHandler:0000000000000000 HAL_PWR_PVD_IRQHandler
     /tmp/ccKABB6j.s:1051   .text.HAL_PWR_PVDCallback:0000000000000000 HAL_PWR_PVDCallback
     /tmp/ccKABB6j.s:1039   .text.HAL_PWR_PVD_IRQHandler:0000000000000020 $d
     /tmp/ccKABB6j.s:1044   .text.HAL_PWR_PVDCallback:0000000000000000 $t
                     .debug_frame:0000000000000010 $d

NO UNDEFINED SYMBOLS
ARM GAS  /tmp/ccKABB6j.s 			page 49


